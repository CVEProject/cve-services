const CONSTANTS = require('../constants')
const cveSchemaV4 = require('./jsonSchemaV4')
const cveSchemaV5 = require('./jsonSchemaV5')
const argon2 = require('argon2')
const logger = require('./logger')
const Validator = require('jsonschema').Validator
const v = new Validator()
const uuid = require('uuid')
const errors = require('./error')
const error = new errors.MiddlewareError()
const RepositoryFactory = require('../repositories/repositoryFactory')

function createCtxAndReqUUID (req, res, next) {
  try {
    req.ctx = {
      uuid: uuid.v4(),
      org: req.header(CONSTANTS.AUTH_HEADERS.ORG),
      user: req.header(CONSTANTS.AUTH_HEADERS.USER),
      key: req.header(CONSTANTS.AUTH_HEADERS.KEY),
      repositories: new RepositoryFactory()
    }

    logger.info(JSON.stringify({ uuid: req.ctx.uuid, path: req.path }))
    next()
  } catch (err) {
    next(err)
  }
}

async function validateUser (req, res, next) {
  const org = req.ctx.org
  const user = req.ctx.user
  const key = req.ctx.key
  const userRepo = req.ctx.repositories.getUserRepository()
  const orgRepo = req.ctx.repositories.getOrgRepository()

  try {
    if (!org) {
      return res.status(400).json(error.badRequest(CONSTANTS.AUTH_HEADERS.ORG))
    }

    if (!user) {
      return res.status(400).json(error.badRequest(CONSTANTS.AUTH_HEADERS.USER))
    }

    if (!key) {
      return res.status(400).json(error.badRequest(CONSTANTS.AUTH_HEADERS.KEY))
    }

    logger.info({ uuid: req.ctx.uuid, message: 'Authenticating user: ' + user }) // userUUID may be null if user does not exist
    const orgUUID = await orgRepo.getOrgUUID(org)
    if (!orgUUID) {
      logger.info({ uuid: req.ctx.uuid, message: org + ' organization does not exist. User authentication FAILED for ' + user })
      return res.status(401).json(error.unauthorized())
    }

    const result = await userRepo.findOneByUserNameAndOrgUUID(user, orgUUID)
    if (!result) {
      logger.warn(JSON.stringify({ uuid: req.ctx.uuid, message: 'User not found. User authentication FAILED for ' + user }))
      return res.status(401).json(error.unauthorized())
    }

    if (!result.active) {
      logger.warn(JSON.stringify({ uuid: req.ctx.uuid, message: 'User deactivated. Authentication failed for ' + user }))
      return res.status(401).json(error.unauthorized())
    }

    const isPwd = await argon2.verify(result.secret, key)
    if (!isPwd) {
      logger.warn(JSON.stringify({ uuid: req.ctx.uuid, message: 'Incorrect apikey. User authentication FAILED for ' + user }))
      return res.status(401).json(error.unauthorized())
    }

    logger.info({ uuid: req.ctx.uuid, message: 'SUCCESSFUL user authentication for ' + user })
    next()
  } catch (err) {
    next(err)
  }
}

// Checks that the requester belongs to an org that has the 'SECREATARIAT' role
async function onlySecretariat (req, res, next) {
  const org = req.ctx.org
  const orgRepo = req.ctx.repositories.getOrgRepository()

  try {
    const isSec = await orgRepo.isSecretariat(org)
    if (!isSec) {
      logger.info({ uuid: req.ctx.uuid, message: org + ' is NOT a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT })
      return res.status(403).json(error.secretariatOnly())
    }

    logger.info({ uuid: req.ctx.uuid, message: 'Confirmed ' + org + ' as a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT })
    next()
  } catch (err) {
    next(err)
  }
}

// Checks that the requester belongs to an org that has the 'SECREATARIAT' role or is a user with the 'ADMIN' role
async function onlySecretariatOrAdmin (req, res, next) {
  const org = req.ctx.org
  const username = req.ctx.user
  const orgRepo = req.ctx.repositories.getOrgRepository()
  const userRepo = req.ctx.repositories.getUserRepository()

  try {
    const isSec = await orgRepo.isSecretariat(org)
    const isAdmin = await userRepo.isAdmin(username, org)
    if (!isSec && !isAdmin) {
      logger.info({ uuid: req.ctx.uuid, message: 'Request denied because \'' + org + '\' is NOT a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT + ' and \'' + username + '\' is not an ' + CONSTANTS.USER_ROLE_ENUM.ADMIN + ' user.' })
      return res.status(403).json(error.notOrgAdminOrSecretariat())
    }

    logger.info({ uuid: req.ctx.uuid, message: 'Confirmed ' + org + ' as a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT + ' or an ' + CONSTANTS.USER_ROLE_ENUM.ADMIN + ' user.' })
    next()
  } catch (err) {
    next(err)
  }
}

// Checks that the requester belongs to an org that has the 'CNA' role
async function onlyCnas (req, res, next) {
  const shortName = req.ctx.org
  const orgRepo = req.ctx.repositories.getOrgRepository()

  try {
    const org = await orgRepo.findOneByShortName(shortName) // org exists
    if (org.authority.active_roles.includes(CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT)) {
      logger.info({ uuid: req.ctx.uuid, message: org.short_name + ' is a ' + CONSTANTS.AUTH_ROLE_ENUM.SECRETARIAT + ' so until Root organizations are implemented this role is allowed.' })
      next()
    } else if (org.authority.active_roles.includes(CONSTANTS.AUTH_ROLE_ENUM.CNA)) { // the org is a CNA
      logger.info({ uuid: req.ctx.uuid, message: 'Confirmed ' + org.short_name + ' as a ' + CONSTANTS.AUTH_ROLE_ENUM.CNA })
      next()
    } else {
      logger.info({ uuid: req.ctx.uuid, message: org.short_name + ' is NOT a ' + CONSTANTS.AUTH_ROLE_ENUM.CNA })
      return res.status(403).json(error.cnaOnly())
    }
  } catch (err) {
    next(err)
  }
}

function validateCveJsonSchema (req, res, next) {
  const cve = req.body
  const cveVersion = cve.data_version
  let cveState = cve.CVE_data_meta
  let schema
  logger.info({ uuid: req.ctx.uuid, message: 'Validating CVE JSON schema.' })

  if (cveState) {
    cveState = cveState.STATE
  }

  if (cveVersion === '4.0') {
    if (cveState === CONSTANTS.CVE_STATES.PUBLIC) {
      schema = cveSchemaV4.publicSchema
    } else if (cveState === CONSTANTS.CVE_STATES.RESERVED) {
      schema = cveSchemaV4.reservedSchema
    } else if (cveState === CONSTANTS.CVE_STATES.REJECT) {
      schema = cveSchemaV4.rejectSchema
    } else {
      logger.error(JSON.stringify({ uuid: req.ctx.uuid, message: 'CVE JSON schema validation FAILED.' }))
      return res.status(400).json(error.invalidJsonSchema(['instance.CVE_data_meta.STATE is not one of enum values']))
    }
  } else if (cveVersion === '5.0') {
    if (cveState === CONSTANTS.CVE_STATES.PUBLIC) {
      schema = cveSchemaV5.publicSchema
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.1.json?20190610')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v3.0.json?20170531')
      v.addSchema(schema, '/https://www.first.org/cvss/cvss-v2.0.json?20170531')
    } else if (cveState === CONSTANTS.CVE_STATES.RESERVED) {
      schema = cveSchemaV5.reservedSchema
    } else if (cveState === CONSTANTS.CVE_STATES.REJECT) {
      schema = cveSchemaV5.rejectSchema
    } else {
      logger.error(JSON.stringify({ uuid: req.ctx.uuid, message: 'CVE JSON schema validation FAILED.' }))
      return res.status(400).json(error.invalidJsonSchema(['instance.CVE_data_meta.STATE is not one of enum values']))
    }
  } else {
    logger.error(JSON.stringify({ uuid: req.ctx.uuid, message: 'CVE JSON schema validation FAILED.' }))
    return res.status(400).json(error.invalidJsonSchema(['instance.data_version is not one of enum values']))
  }

  const result = v.validate(cve, schema, { nestedErrors: true })

  if (result.valid) {
    logger.info(JSON.stringify({ uuid: req.ctx.uuid, message: 'SUCCESSFUL CVE JSON schema validation.' }))
    next()
  } else {
    logger.error(JSON.stringify({ uuid: req.ctx.uuid, message: 'CVE JSON schema validation FAILED.' }))

    const temp = result.toString().split('\n')
    const errors = []
    temp.forEach((error) => {
      if (error !== '') {
        const array = error.split(':', 2)
        errors.push(array[1].trim())
      }
    })

    return res.status(400).json(error.invalidJsonSchema(errors))
  }
}

function largeInputErrorHandler (err, req, res, next) {
  if (err.status && err.message) {
    console.warn('Request failed validation because entity too large')
    console.info((JSON.stringify(err)))
    return res.status(400).json(error.recordTooLarge(errors))
  } else {
    next(err)
  }
}

function errorHandler (err, req, res, next) {
  logger.error(JSON.stringify({ error: err.stack }))
  return res.status(500).json(error.serviceNotAvailable())
}

module.exports = {
  validateUser,
  onlySecretariat,
  onlySecretariatOrAdmin,
  onlyCnas,
  createCtxAndReqUUID,
  validateCveJsonSchema,
  largeInputErrorHandler,
  errorHandler
}
