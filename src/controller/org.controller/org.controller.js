require('dotenv').config()
const User = require('../../model/user')
const Org = require('../../model/org')
const logger = require('../../middleware/logger')
const argon2 = require('argon2')
const CONSTANTS = require('../../constants')
const cryptoRandomString = require('crypto-random-string')
const utils = require('../../utils/utils')
const uuid = require('uuid')
const errors = require('./error')
const error = new errors.OrgControllerError()

// Get the details of all orgs
async function getOrgs (req, res, next) {
  try {
    const repo = req.ctx.repositories.getOrgRepository()
    const result = await repo.aggregate([
      {
        $project: {
          _id: false,
          UUID: true,
          short_name: true,
          name: true,
          'authority.active_roles': true,
          'policies.id_quota': true,
          time: true
        }
      }
    ])

    logger.info({ message: 'The orgs were sent to the user.' })
    return res.status(200).json(result)
  } catch (err) {
    next(err)
  }
}

// Get the details of a single org for the specified shortname
async function getOrg (req, res, next) {
  try {
    const orgShortName = req.ctx.org
    const shortName = req.ctx.params.shortname
    const repo = req.ctx.repositories.getOrgRepository()
    const isSecretariat = await repo.isSecretariat(orgShortName)
    let returned = false

    if (orgShortName !== shortName && !isSecretariat) {
      returned = true
      logger.info({ message: shortName + ' organization can only be viewed by the users of the same organization or the Secretariat.' })
      return res.status(403).json(error.notSameOrgOrSecretariat())
    }

    if (!returned) {
      const result = await repo.aggregate([
        {
          $match: { short_name: shortName }
        },
        {
          $project: {
            _id: false,
            UUID: true,
            short_name: true,
            name: true,
            'authority.active_roles': true,
            'policies.id_quota': true,
            time: true
          }
        }
      ])

      if (utils.isEmptyObject(result)) {
        logger.info({ message: shortName + ' organization does not exist.' })
        return res.status(404).json(error.orgDneParam(shortName))
      }

      logger.info({ message: shortName + ' organization was sent to the user.', org: result })
      return res.status(200).json(result[0])
    }
  } catch (err) {
    next(err)
  }
}

async function getUsers (req, res, next) {
  try {
    const shortName = req.ctx.org
    const orgShortName = req.ctx.params.shortname
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()
    const orgUUID = await orgRepo.getOrgUUID(orgShortName)
    let returned = false

    if (!orgUUID) {
      returned = true
      logger.info({message: orgShortName + ' organization does not exist.'})
      return res.status(404).json(error.orgDneParam(orgShortName))
    }

    if (orgShortName !== shortName && !returned) {
      returned = true
      logger.info({ message: orgShortName + ' organization can only be viewed by the users of the same organization.' })
      return res.status(403).json({ error: 'NOT_OWNER', message: 'This information can only be viewed by the users of the same organization.' })
    }

    if (!returned) {
      const result = await userRepo.aggregate([
        {
          $match: { org_UUID: orgUUID }
        },
        {
          $project: {
            _id: false,
            UUID: true,
            username: true,
            org_UUID: true,
            name: true,
            active: true,
            time: true
          }
        }
      ])

      logger.info({ message: `The users of ${orgShortName} organization were sent to the user.` })
      return res.status(200).json(result)
    }
  } catch (err) {
    next(err)
  }
}

// Get the details of a single user for the specified username
async function getUser (req, res, next) {
  try {
    const shortName = req.ctx.org
    const username = req.ctx.params.username
    const orgShortName = req.ctx.params.shortname
    let returned = false
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const isSecretariat = await orgRepo.isSecretariat(shortName)

    if (orgShortName !== shortName && !isSecretariat) {
      returned = true
      logger.info({ message: shortName + ' organization can only be viewed by that organization\'s users or the Secretariat.' })
      return res.status(403).json(error.notSameOrgOrSecretariat())
    }

    const orgUUID = await orgRepo.getOrgUUID(orgShortName)
    if (!orgUUID && !returned) {
      returned = true
      logger.info({ message: orgShortName + ' organization does not exist.' })
      return res.status(404).json(error.orgDneParam(orgShortName))
    }

    if (!returned) {
      const userRepo = req.ctx.repositories.getUserRepository()
      const result = await userRepo.aggregate([
        {
          $match: { username: username, org_UUID: orgUUID }
        },
        {
          $project: {
            _id: false,
            UUID: true,
            username: true,
            org_UUID: true,
            name: true,
            active: true,
            time: true
          }
        }
      ])

      if (utils.isEmptyObject(result)) {
        logger.info({ message: username + ' does not exist.' })
        return res.status(404).json(error.userDne(username))
      }

      logger.info({ message: username + ' was sent to the user.', user: result })
      return res.status(200).json(result[0])
    }
  } catch (err) {
    next(err)
  }
}

// Get details on ID quota for an org with the specified org shortname
async function getOrgIdQuota (req, res, next) {
  try {
    const orgShortName = req.ctx.org
    const shortName = req.ctx.params.shortname
    const repo = req.ctx.repositories.getOrgRepository()
    const isSecretariat = await repo.isSecretariat(orgShortName)
    if (orgShortName !== shortName && !isSecretariat) {
      logger.info({ message: shortName + ' organization id quota can only be viewed by the users of the same organization or the Secretariat.' })
      return res.status(403).json(error.notSameOrgOrSecretariat())
    }

    let result = await repo.findOneByShortName(shortName)
    if (!result) {
      logger.info({ message: shortName + ' organization does not exist.' })
      return res.status(404).json(error.orgDneParam(shortName))
    }

    const returnPayload = {
      id_quota: result.policies.id_quota,
      total_reserved: null,
      available: null
    }

    const query = {
      owning_cna: await repo.getOrgUUID(shortName),
      state: 'RESERVED'
    }
    const cveIdRepo = req.ctx.repositories.getCveIdRepository()
    result = await cveIdRepo.countDocuments(query)
    returnPayload.total_reserved = result
    returnPayload.available = returnPayload.id_quota - returnPayload.total_reserved

    logger.info({ message: 'The organization\'s id quota was returned to the user.', details: returnPayload })
    return res.status(200).json(returnPayload)
  } catch (err) {
    next(err)
  }
}

// Creates a new org only if the org doesn't exist for the specified shortname. If the org exists, we do not update the org.
async function createOrg (req, res, next) {
  try {
    const newOrg = new Org(req.ctx.body)
    const orgRepo = req.ctx.repositories.getOrgRepository()

    const result = await orgRepo.findOneByShortName(newOrg.short_name) // Find org in MongoDB
    if (result) {
      logger.info({ message: newOrg.short_name + ' organization was not created because it already exists.' })
      return res.status(400).json(error.orgExists(newOrg.short_name))
    }

    newOrg.inUse = false

    // policies are undefined
    if (newOrg.authority.active_roles.length === 0) {
      newOrg.authority.active_roles = [CONSTANTS.AUTH_ROLE_ENUM.CNA] // default role
    }

    if (newOrg.UUID === undefined || newOrg.UUID === null) {
      newOrg.UUID = uuid.v4()
    }

    if (newOrg.policies.id_quota === undefined || newOrg.policies.id_quota === null) {
      newOrg.policies.id_quota = CONSTANTS.DEFAULT_ID_QUOTA
    }

    await orgRepo.updateByOrgUUID(newOrg.UUID, newOrg, { upsert: true }) // Create org in MongoDB if it doesn't exist

    const responseMessage = {
      message: newOrg.short_name + ' organization was successfully created.',
      created: newOrg
    }

    const payload = {
      action: 'create_org',
      change: newOrg.short_name + ' organization was successfully created.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
      org: newOrg
    }
    const userRepo = req.ctx.repositories.getUserRepository()
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
    logger.info(JSON.stringify(payload))
    return res.status(200).json(responseMessage)
  } catch (err) {
    next(err)
  }
}

// Updates an org only if the org exist for the specified shortname. If no org exists, we do not create the org.
async function updateOrg (req, res, next) {
  try {
    const shortName = req.ctx.params.shortname
    const newOrg = new Org()
    let returned = false
    let quota
    let name
    let shortname
    const removeRoles = []
    const addRoles = []
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const org = await orgRepo.findOneByShortName(shortName)

    // org doesn't exist
    if (!org) {
      returned = true
      logger.info({ message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })
      return res.status(404).json(error.orgDneParam(shortName))
    }

    // parsing query parameters
    if ('id_quota' in req.ctx.query) {
      quota = req.ctx.query.id_quota
    }
    if ('name' in req.ctx.query) {
      name = req.ctx.query.name
    }
    if ('shortname' in req.ctx.query) {
      shortname = req.ctx.query.shortname
    }
    if ('active_roles.add' in req.ctx.query) {
      if (Array.isArray(req.ctx.query['active_roles.add'])) {
        req.ctx.query['active_roles.add'].forEach(r => {
          addRoles.push(r)
        })
      }
    }
    if ('active_roles.remove' in req.ctx.query) {
      if (Array.isArray(req.ctx.query['active_roles.remove'])) {
        req.query['active_roles.remove'].forEach(r => {
          removeRoles.push(r)
        })
      }
    }

    // updating the org's roles
    if (org && !returned) {
      const roles = org.authority.active_roles
      newOrg.policies.id_quota = org.policies.id_quota

      // adding roles
      addRoles.forEach(role => {
        if (!roles.includes(role)) {
          roles.push(role)
        }
      })

      // removing roles
      removeRoles.forEach(role => {
        const index = roles.indexOf(role)

        if (index > -1) {
          roles.splice(index, 1)
        }
      })

      newOrg.authority.active_roles = roles
    }

    // updating the org's quota
    if (quota && !returned) {
      newOrg.policies.id_quota = quota
    }

    // updating the org's name (the name field is never an empty string due to the stripping of the quotes and double quotes)
    if (name && !returned) {
      newOrg.name = name
    }

    // updating the org's shortname (the shortname field is never an empty string due to the stripping of the quotes and double quotes)
    if (shortname && !returned) {
      newOrg.short_name = shortname
      const result = await orgRepo.findOneByShortName(newOrg.short_name)

      if (result && !returned) {
        returned = true
        return res.status(403).json(error.duplicateShortname(newOrg.short_name))
      }
    }

    // update org
    if (!returned) {
      const result = await orgRepo.updateByOrgUUID(org.UUID, newOrg)

      if (result.n === 0) {
        logger.info({ message: shortName + ' organization could not be updated in MongoDB because it does not exist.' })
        return res.status(404).json(error.orgDneParam(shortName))
      }

      const responseMessage = {
        message: shortName + ' organization was successfully updated.',
        updated: newOrg
      }

      const payload = {
        action: 'update_org',
        change: shortName + ' organization was successfully updated.',
        req_UUID: req.ctx.uuid,
        org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
        org: newOrg
      }
      const userRepo = req.ctx.repositories.getUserRepository()
      payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
      logger.info(JSON.stringify(payload))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

// Creates a user only if the org exist and the user does not exist for the specified shortname and username
async function createUser (req, res, next) {
  try {
    const orgShortName = req.ctx.params.shortname
    const newUser = new User(req.ctx.body)
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const userRepo = req.ctx.repositories.getUserRepository()

    const orgUUID = await orgRepo.getOrgUUID(orgShortName)
    if (!orgUUID) {
      logger.info({ message: 'The user could not be created because ' + orgShortName + ' organization does not exist.' })
      return res.status(404).json(error.orgDneParam(orgShortName))
    }

    if (newUser.org_UUID === undefined || newUser.org_UUID === null) {
      newUser.org_UUID = orgUUID
    }

    // If org's UUID was provided in the body, it must match the org's UUID of the org provided in the URL params
    if (newUser.org_UUID !== orgUUID) {
      const temp = await orgRepo.findOneByUUID(newUser.org_UUID)
      let sn

      if (!temp) {
        sn = null
      } else {
        sn = temp.short_name
      }

      return res.status(400).json(error.shortnameMismatch(orgShortName, sn))
    }

    let result = await orgRepo.findOneByUUID(newUser.org_UUID) // Check the org exists

    if (!result) {
      logger.info({ message: 'The user could not be created because ' + orgShortName + ' organization does not exist.' })
      return res.status(400).json(error.orgDneParam(orgShortName))
    }

    newUser.active = true
    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })
    newUser.secret = await argon2.hash(randomKey)

    if (newUser.UUID === undefined || newUser.UUID === null) {
      newUser.UUID = uuid.v4()
    }

    result = await userRepo.findOneByUserNameAndOrgUUID(newUser.username, newUser.org_UUID) // Find user in MongoDB

    if (result) {
      logger.info({ message: newUser.username + ' was not created because it already exists.' })
      return res.status(400).json(error.userExists(newUser.username))
    }
    await userRepo.updateByUserNameAndOrgUUID(newUser.username, newUser.org_UUID, newUser, { upsert: true }) // Create user in MongoDB if it doesn't exist

    newUser.secret = randomKey
    const responseMessage = {
      message: newUser.username + ' was successfully created.',
      created: newUser
    }

    const payload = {
      action: 'create_user',
      change: newUser.username + ' was successfully created.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
      user: newUser
    }
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
    logger.info(JSON.stringify(payload))
    return res.status(200).json(responseMessage)
  } catch (err) {
    next(err)
  }
}

// Updates a user only if the user exist for the specified username. If no user exists, it does not create the user.
async function updateUser (req, res, next) {
  try {
    const username = req.ctx.params.username
    const shortName = req.ctx.params.shortname
    const newUser = new User()
    let returned = false
    let nameChanged = false
    let newUsername
    let newOrgShortName
    let active
    const name = {
      first: null,
      ast: null,
      middle: null,
      surname: null,
      suffix: null
    }
    const userRepo = req.ctx.repositories.getUserRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()

    const orgUUID = await orgRepo.getOrgUUID(shortName)
    if (!orgUUID) {
      returned = true
      logger.info({ message: 'The user could not be updated because ' + shortName + ' organization does not exist.' })
      return res.status(404).json(error.orgDneParam(shortName))
    }

    const user = await userRepo.findOneByUserNameAndOrgUUID(username, orgUUID)
    if (!user) {
      returned = true
      logger.info({ message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })
      return res.status(404).json(error.userDne(username))
    }

    if ('new_username' in req.ctx.query) {
      newUsername = req.ctx.query.new_username
    }
    if ('new_cna_shortname' in req.ctx.query) {
      newOrgShortName = req.ctx.query.new_cna_shortname
    }
    if ('active' in req.ctx.query) {
      active = req.ctx.query.active
    }
    if ('name.first' in req.ctx.query) {
      name.first = req.ctx.query['name.first']
      user.name.first = name.first
      nameChanged = true
    }
    if ('name.last' in req.ctx.query) {
      name.last = req.ctx.query['name.last']
      user.name.last = name.last
      nameChanged = true
    }
    if ('name.middle' in req.ctx.query) {
      name.middle = req.ctx.query['name.middle']
      user.name.middle = name.middle
      nameChanged = true
    }
    if ('name.suffix' in req.ctx.query) {
      name.suffix = req.ctx.query['name.suffix']
      user.name.suffix = name.suffix
      nameChanged = true
    }
    if ('name.surname' in req.ctx.query) {
      name.surname = req.ctx.query['name.surname']
      user.name.surname = name.surname
      nameChanged = true
    }

    // updating the user's username (the username field is never an empty string due to the stripping of the quotes and double quotes)
    if (newUsername && !returned) {
      newUser.username = newUsername
    }

    if (active && !returned) {
      newUser.active = active
    }

    // only update the name sub fields that were changed
    if (nameChanged && !returned) {
      newUser.name = user.name
    }

    // check if the new org exist
    if (newOrgShortName && !returned) {
      newUser.org_UUID = await orgRepo.getOrgUUID(newOrgShortName)

      if (!newUser.org_UUID) {
        returned = true
        logger.info({ message: 'The user could not be updated because ' + newOrgShortName + ' organization does not exist.' })
        return res.status(404).json(error.orgDne(newOrgShortName))
      }
    }

    // check if org has user of same username already
    if ((newUsername && newOrgShortName) && !returned) {
      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: newUser.username })
      if (duplicateUsers.length) {
        returned = true
        logger.info({ message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same name.' })
        return res.status(403).json(error.duplicateUsername(newOrgShortName, newUsername))
      }
    } else if (newUsername && !returned) {
      const duplicateUsers = await userRepo.find({ org_UUID: orgUUID, username: newUser.username })
      if (duplicateUsers.length) {
        returned = true
        logger.info({ message: 'The user could not be updated because ' + shortName + ' organization contains a user with the same name.' })
        return res.status(403).json(error.duplicateUsername(shortName, newUsername))
      }
    } else if (newOrgShortName && !returned) {
      const duplicateUsers = await userRepo.find({ org_UUID: newUser.org_UUID, username: username })
      if (duplicateUsers.length) {
        returned = true
        logger.info({ message: 'The user could not be updated because ' + newOrgShortName + ' organization contains a user with the same name.' })
        return res.status(403).json(error.duplicateUsername(newOrgShortName, username))
      }
    }

    if (!returned) {
      const result = await userRepo.updateByUserNameAndOrgUUID(username, orgUUID, newUser)

      if (result.n === 0) {
        logger.info({ message: 'The user could not be updated because ' + username + ' does not exist for ' + shortName + ' organization.' })
        return res.status(404).json(error.userDne(username))
      }

      const responseMessage = {
        message: username + ' was successfully updated.',
        updated: newUser
      }

      const payload = {
        action: 'update_user',
        change: username + ' was successfully updated.',
        req_UUID: req.ctx.uuid,
        org_UUID: await orgRepo.getOrgUUID(req.ctx.org),
        user: newUser
      }
      payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
      logger.info(JSON.stringify(payload))
      return res.status(200).json(responseMessage)
    }
  } catch (err) {
    next(err)
  }
}

// Resets the user secret
async function resetSecret (req, res, next) {
  try {
    const username = req.ctx.params.username
    const orgShortName = req.ctx.params.shortname
    const newUser = new User()
    const randomKey = cryptoRandomString({ length: CONSTANTS.CRYPTO_RANDOM_STRING_LENGTH })
    newUser.secret = await argon2.hash(randomKey) // store in db
    newUser.username = username
    const userRepo = req.ctx.repositories.getUserRepository()
    const orgRepo = req.ctx.repositories.getOrgRepository()
    const orgUUID = await orgRepo.getOrgUUID(orgShortName) // userUUID may be null if user does not exist

    if (!orgUUID) {
      logger.info({ messsage: orgShortName + ' organization does not exist.' })
      return res.status(404).json(error.orgDneParam(orgShortName))
    }

    const result = await userRepo.updateByUserNameAndOrgUUID(newUser.username, orgUUID, newUser)
    if (result.n === 0) {
      logger.info({ message: 'The user could not be updated because ' + username + ' does not exist for ' + orgShortName + ' organization.' })
      return res.status(404).json(error.userDne(username))
    }

    logger.info({ message: `The API secret was successfully reset and sent to ${username}` })
    const payload = {
      action: 'reset_userAPIkey',
      change: 'API secret was successfully reset.',
      req_UUID: req.ctx.uuid,
      org_UUID: await orgRepo.getOrgUUID(req.ctx.org)
    }
    payload.user_UUID = await userRepo.getUserUUID(req.ctx.user, payload.org_UUID)
    logger.info(JSON.stringify(payload))
    return res.status(200).json({ 'API-secret': randomKey })
  } catch (err) {
    next(err)
  }
}

module.exports = {
  ORG_ALL: getOrgs,
  ORG_SINGLE: getOrg,
  ORG_CREATE_SINGLE: createOrg,
  ORG_UPDATE_SINGLE: updateOrg,
  USER_ALL: getUsers,
  ORG_ID_QUOTA: getOrgIdQuota,
  USER_SINGLE: getUser,
  USER_CREATE_SINGLE: createUser,
  USER_UPDATE_SINGLE: updateUser,
  USER_RESET_SECRET: resetSecret
}
