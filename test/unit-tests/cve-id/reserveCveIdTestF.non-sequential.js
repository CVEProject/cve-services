
const server = require('../../../test-utils/index')
const chai = require('chai')
const expect = chai.expect
chai.use(require('chai-http'))
const userAHeader = require('./mockObjects.non-sequential').userAHeader
const orgA = require('./mockObjects.non-sequential').orgA
const secretariatOrg = require('./mockObjects.non-sequential').secretariatOrg
const secretariatUser = require('./mockObjects.non-sequential').secretariatUser
const year = require('./mockObjects.non-sequential').year
const reservedByOther = require('../../../test-utils/reserveCaseF.non-sequential').reservedByOther
const errors = require('../../../src/controller/cve-id.controller/error')
const error = new errors.CveIdControllerError()
const testRepo = require('../../../test-utils/repositories')
const cveIdTestRepo = new testRepo.CveIdReservePoolIncremented10IdsCaseF()
const cveIdRangeTestRepo = new testRepo.CveIdRangeReserveNonSequentialCaseF()

describe('Test ID Reservator for Non-Sequential Case F', () => {
  context('Case F', () => {
    it(`CveId Range document for year ${year} is full after race condition in pool increment`, (done) => {
      // perform the request to the api
      chai.request(server)
        .post(`/cve-id-reserve-f-year-full-after-race-condition?short_name=${orgA.short_name}&cve_year=${year}&amount=10&batch_type=non-sequential`)
        .set(userAHeader)
        .end((err, res) => {
          if (err) {
            done(err)
          }

          // checking header
          const quotaHeader = orgA.policies.id_quota.toString()
          expect(res.header).to.have.property('cve-api-remaining-quota').and.to.equal(quotaHeader)

          // assert expected response
          expect(res).to.have.status(403)
          expect(res).to.have.property('body').and.to.be.a('object')
          const errObj = error.yearRangeFull(year)
          expect(res.body.error).to.equal(errObj.error)
          expect(res.body.message).to.equal(errObj.message)

          // check total count of reserved ids by userA
          const docs = cveIdTestRepo.getCveIdDocuments()
          let reservedCounter = 0
          docs.forEach(doc => {
            if (doc.owning_cna === orgA.UUID && doc.cve_year === year && doc.state === 'RESERVED') {
              reservedCounter++
            }
          })
          expect(reservedCounter).to.equal(0)

          // check count of available ids
          let availableCounter = 0
          docs.forEach(doc => {
            if (doc.cve_year === year && doc.state === 'AVAILABLE') {
              availableCounter++
            }
          })
          expect(availableCounter).to.equal(0)

          // check that unreserved ids by userA are reserved
          const rangeDoc = cveIdRangeTestRepo.getCveIdRange()
          const topId = rangeDoc.ranges.general.top_id
          const reservedDocs = []

          for (let i = 0; i < docs.length; i++) {
            for (let j = 0; j < reservedByOther.length; j++) {
              if (docs[i].cve_id === reservedByOther[j] && docs[i].cve_year === year) {
                reservedDocs.push(docs[i])
                break
              }
            }
          }
          expect(reservedDocs).to.have.lengthOf(20)
          reservedDocs.forEach(obj => {
            const index = parseInt(obj.cve_id.match(/\d+$/g))
            expect(index).to.be.lessThan(topId + 1) // check that the id is less than the current top id
            expect(obj).to.have.property('state').and.to.equal('RESERVED')
            expect(obj).to.have.property('owning_cna').and.to.equal(secretariatOrg.UUID)
            expect(obj).to.have.nested.property('requested_by.cna').and.to.equal(secretariatUser.org_UUID)
            expect(obj).to.have.nested.property('requested_by.user').and.to.equal(secretariatUser.UUID)
          })

          done()
        })
    })
  })
})
